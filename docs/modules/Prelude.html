<!doctype html>
<html>
<head>
  <link rel="stylesheet" type="text/css" href="style.css" />
  <link rel="stylesheet" type="text/css" href="../style.css" />
  <title>Granule documentation - Prelude</title>
</head>
<body>
<div id="navigator">
  <b>Modules</b><br /><br />
<a href='../index.html'><i>Top-level</i><br /></a><ul><li><a href='Primitives.html'>Primitives</a></li><br /><li><a href='Bool.html'>Bool</a></li><li><a href='Cake.html'>Cake</a></li><li><a href='Choice.html'>Choice</a></li><li><a href='Coffee.html'>Coffee</a></li><li><a href='Either.html'>Either</a></li><li><a href='Existential.html'>Existential</a></li><li><a href='File.html'>File</a></li><li><a href='Fin.html'>Fin</a></li><li><a href='Fix.html'>Fix</a></li><li><a href='Graph.html'>Graph</a></li><li><a href='List.html'>List</a></li><li><a href='Maybe.html'>Maybe</a></li><li><a href='Nat.html'>Nat</a></li><li><a href='Parallel.html'>Parallel</a></li><li><a href='Prelude.html'>Prelude</a></li><li><a href='Result.html'>Result</a></li><li><a href='Stack.html'>Stack</a></li><li><a href='Vec.html'>Vec</a></li></ul>
</div>
<div id="content">
  <div id="logo">
    <img src="../images/gr-blue.png" />
  </div>
  <b>Module Prelude</b><br /><br />
<section><h2>Meta-data</h2><ul><li><b>Description</b>: Common functions for Granule programs</li><li><b>Authors</b>: Dominic Orchard, Vilem-Benjamin Liepelt</li><li><b>License</b>: BSD3</li><li><b>Copyright</b>: (c) Authors 2018</li><li><b>Issue-tracking</b>: https://github.com/dorchard/granule/issues</li><li><b>Repository</b>: https://github.com/dorchard/granule</li></ul></section><section><h2>Contents</h2><section><div class='mininav'><ul><li><a href='#standardfunctionalcomponents'> Standard functional components</a></li><li><a href='#numericfunctionsandconstants'> Numeric functions and constants</a></li><li><a href='#combinatorsinvolvingproductspairs'> Combinators involving products (pairs)</a></li><li><a href='#semiringpolymorphiccombinators'> Semiring-polymorphic combinators</a></li><li><a href='#coeffectspecifccombinators'> Coeffect-specifc combinators</a></li></ul></div></section><a name = standardfunctionalcomponents><h3><a href='#' class='toplink'>[top]</a> Standard functional components</h3></a><div class='code'><pre>id : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>} 
   . a -> a</pre></div><div class='desc'> Identity function</div><div class='code'><pre>flip : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, b : <span class='constName'>Type</span>, c : <span class='constName'>Type</span>} 
     . (a -> b -> c) -> b -> a -> c</pre></div><div class='desc'> Flip the order of parameters</div><div class='code'><pre>const : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, b : <span class='constName'>Type</span>, s : <span class='constName'>Coeffect</span>} 
      . a -> b [<span class='coeff'>(0 : s)</span>] -> a</pre></div><div class='desc'> Constant combinator NB: Throws away its second argument and returns the first</div><div class='code'><pre>lcompose : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, b : <span class='constName'>Type</span>, c : <span class='constName'>Type</span>} 
         . (b -> c) -> (a -> b) -> a -> c</pre></div><div class='desc'> linear function composition (the composition operator <span class='inline'>g ∘ f</span> resolves to whatever is bound to <span class='inline'>compose</span>)</div><div class='code'><pre>until : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>} 
      . (a -> <span class='constName'>Bool</span>) [<span class='coeff'>1..<span class='constName'>∞</span></span>] -> (a -> a) [<span class='coeff'>0..<span class='constName'>∞</span></span>] -> a [<span class='coeff'>2..<span class='constName'>∞</span></span>] -> a</pre></div><div class='desc'> Apply f to x until p holds</div><div class='code'><pre>if0 : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>} 
    . <span class='constName'>Int</span> [<span class='coeff'>0..1</span>] -> a [<span class='coeff'>0..1</span>] -> a [<span class='coeff'>0..1</span>] -> a</pre></div><div class='desc'> Conditional on integers Returns <span class='inline'>x</span> if <span class='inline'>g</span> is zero, else returns <span class='inline'>y</span></div><a name = numericfunctionsandconstants><h3><a href='#' class='toplink'>[top]</a> Numeric functions and constants</h3></a><div class='code'><pre>sign : <span class='constName'>Int</span> [<span class='coeff'>1
     ..2</span>] -> <span class='constName'>Int</span></pre></div><div class='desc'> Given some n, return + 1 iff n is positive + -1 iff n is negative + 0 otherwise</div><div class='code'><pre>pi : <span class='constName'>Float</span></pre></div><div class='desc'> An approximation of pi</div><div class='code'><pre>e : <span class='constName'>Float</span></pre></div><div class='desc'> An approximation of Euler's number</div><a name = combinatorsinvolvingproductspairs><h3><a href='#' class='toplink'>[top]</a> Combinators involving products (pairs)</h3></a><div class='code'><pre>fst : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, b : <span class='constName'>Type</span>, s : <span class='constName'>Coeffect</span>} 
    . (a, b [<span class='coeff'>(0 : s)</span>]) -> a</pre></div><div class='desc'> Extract the left part of a pair</div><div class='code'><pre>snd : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, b : <span class='constName'>Type</span>, s : <span class='constName'>Coeffect</span>} 
    . (a [<span class='coeff'>(0 : s)</span>], b) -> b</pre></div><div class='desc'> Extract the right part of a pair</div><div class='code'><pre>curry : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, b : <span class='constName'>Type</span>, c : <span class='constName'>Type</span>} 
      . ((a, b) -> c) -> a -> b -> c</pre></div><div class='desc'> curry converts an uncurried function to a curried function</div><div class='code'><pre>uncurry : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, b : <span class='constName'>Type</span>, c : <span class='constName'>Type</span>} 
        . (a -> b -> c) -> (a, b) -> c</pre></div><div class='desc'> uncurry converts a curried function to a function on pairs</div><a name = semiringpolymorphiccombinators><h3><a href='#' class='toplink'>[top]</a> Semiring-polymorphic combinators</h3></a><div class='code'><pre>comp : <span class='keyword'>forall</span> {k : <span class='constName'>Coeffect</span>, n : k, m : k, a : <span class='constName'>Type</span>, b : <span class='constName'>Type</span>, c : <span class='constName'>Type</span>} 
     . (b [<span class='coeff'>n</span>] -> c) -> (a [<span class='coeff'>m</span>] -> b) [<span class='coeff'>n</span>] -> a [<span class='coeff'>n * m</span>] -> c</pre></div><div class='desc'> Coeffectful composition</div><div class='code'><pre>boxmap : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, b : <span class='constName'>Type</span>, s : <span class='constName'>Coeffect</span>, r : s} 
       . (a -> b) [<span class='coeff'>r</span>] -> a [<span class='coeff'>r</span>] -> b [<span class='coeff'>r</span>]</pre></div><div class='desc'> Graded necessity is an applicative functor</div><div class='code'><pre>disject : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, k : <span class='constName'>Coeffect</span>, n : k, m : k} 
        . a [<span class='coeff'>m * n</span>] -> (a [<span class='coeff'>n</span>]) [<span class='coeff'>m</span>]</pre></div><div class='desc'> 'Comultiplication' operation showing that graded necessity is a graded comonad</div><div class='code'><pre>extract : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, s : <span class='constName'>Coeffect</span>, r : s} 
        . {((1 : s)) ≤ r} =>
    a [<span class='coeff'>r</span>] -> a</pre></div><div class='desc'> 'Counit' operation showing that graded necessity is a graded comonad</div><div class='code'><pre>pushPair : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, b : <span class='constName'>Type</span>, k : <span class='constName'>Coeffect</span>, c : k} 
         . {c ⨱ c} =>
    (a, b) [<span class='coeff'>c</span>] -> (a [<span class='coeff'>c</span>], b [<span class='coeff'>c</span>])</pre></div><div class='desc'> Push coeffects on a pair into the left and right elements. A distributive law of graded necessity over products. Note however that this is not always defined: the operation {c ⨱ c} is partial and is only defined if the semiring <span class='inline'>k</span> permits this behaviour at <span class='inline'>c</span>. (An example of a semiring where this is not true is for <span class='inline'>k = LNL</span> and <span class='inline'>c = 1</span>).</div><div class='code'><pre>pullPair : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, b : <span class='constName'>Type</span>, k : <span class='constName'>Coeffect</span>, n : k} 
         . (a [<span class='coeff'>n</span>], b [<span class='coeff'>n</span>]) -> (a, b) [<span class='coeff'>n</span>]</pre></div><div class='desc'> Pull coeffects of pair elements outside of the pair</div><div class='code'><pre>copy : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, s : <span class='constName'>Coeffect</span>} 
     . a [<span class='coeff'>(1 + 1 : s)</span>] -> (a, a)</pre></div><div class='desc'> Generic copying of a value into a pair</div><a name = coeffectspecifccombinators><h3><a href='#' class='toplink'>[top]</a> Coeffect-specifc combinators</h3></a><div class='code'><pre>flatten : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, n : <span class='constName'>Nat</span>, m : <span class='constName'>Nat</span>} 
        . (a [<span class='coeff'>n</span>]) [<span class='coeff'>m</span>] -> a [<span class='coeff'>n * m</span>]</pre></div><div class='desc'> Flatten two boxes (with Nat grading)</div><div class='code'><pre>unflatten : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, n : <span class='constName'>Nat</span>, m : <span class='constName'>Nat</span>} 
          . a [<span class='coeff'>n * m</span>] -> (a [<span class='coeff'>n</span>]) [<span class='coeff'>m</span>]</pre></div><div class='desc'> Expand two boxes (with Nat grading)</div></section>
</div>
</body>
</html>