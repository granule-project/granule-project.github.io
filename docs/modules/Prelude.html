<!doctype html>
<html>
<head>
  <link rel="stylesheet" type="text/css" href="style.css" />
  <link rel="stylesheet" type="text/css" href="../style.css" />
  <title>Granule documentation - Prelude</title>
</head>
<body>
<div id="navigator">
  <b>Modules</b><br /><br />
<a href='../index.html'><i>Top-level</i><br /></a><ul><li><a href='Primitives.html'>Primitives</a></li><br /><li><a href='Bool.html'>Bool</a></li><li><a href='Cake.html'>Cake</a></li><li><a href='Choice.html'>Choice</a></li><li><a href='Either.html'>Either</a></li><li><a href='Existential.html'>Existential</a></li><li><a href='File.html'>File</a></li><li><a href='Fin.html'>Fin</a></li><li><a href='Fix.html'>Fix</a></li><li><a href='Graph.html'>Graph</a></li><li><a href='List.html'>List</a></li><li><a href='Maybe.html'>Maybe</a></li><li><a href='Nat.html'>Nat</a></li><li><a href='Parallel.html'>Parallel</a></li><li><a href='Prelude.html'>Prelude</a></li><li><a href='Result.html'>Result</a></li><li><a href='Stack.html'>Stack</a></li><li><a href='Vec.html'>Vec</a></li></ul>
</div>
<div id="content">
  <div id="logo">
    <img src="../images/gr-blue.png" />
  </div>
  <b>Module Prelude</b><br /><br />
<section><ul><li><b>Description</b>: Common functions for Granule programs</li><li><b>Authors</b>: Dominic Orchard, Vilem-Benjamin Liepelt</li><li><b>License</b>: BSD3</li><li><b>Copyright</b>: (c) Authors 2018</li><li><b>Issue-tracking</b>: https://github.com/dorchard/granule/issues</li><li><b>Repository</b>: https://github.com/dorchard/granule</li></ul></section><section><h2>Data types</h2></section><section><h2>Definitions</h2><div class='code'><pre>id : forall {a : Type} . a -> a</pre></div><div class='desc'> Identity function</div><div class='code'><pre>flip : forall {a : Type, b : Type, c : Type} . (a -> b -> c) -> b -> a -> c</pre></div><div class='desc'> Flip the order of parameters</div><div class='code'><pre>const : forall {a : Type, b : Type, s : Coeffect} . a -> b [(0 : s)] -> a</pre></div><div class='desc'> Constant combinator NB: Throws away its second argument and returns the first</div><div class='code'><pre>lcompose : forall {a : Type, b : Type, c : Type} . (b -> c) -> (a -> b) -> a -> c</pre></div><div class='desc'> linear function composition (the composition operator `g ∘ f` resolves to whatever is bound to `compose`)</div><div class='code'><pre>until : forall {a : Type} . (a -> Bool) [1..∞] -> (a -> a) [0..∞] -> a [2..∞] -> a</pre></div><div class='desc'> Apply f to x until p holds</div><div class='code'><pre>if0 : forall {a : Type} . Int [0..1] -> a [0..1] -> a [0..1] -> a</pre></div><div class='desc'> Conditional on integers Returns `x` if `g` is zero, else returns `y`</div><div class='code'><pre>sign : Int [1..2] -> Int</pre></div><div class='desc'></div><div class='code'><pre>pi : Float</pre></div><div class='desc'> An approximation of pi</div><div class='code'><pre>e : Float</pre></div><div class='desc'></div><div class='code'><pre>fst : forall {a : Type, b : Type, s : Coeffect} . (a, b [(0 : s)]) -> a</pre></div><div class='desc'> Extract the left part of a pair</div><div class='code'><pre>snd : forall {a : Type, b : Type, s : Coeffect} . (a [(0 : s)], b) -> b</pre></div><div class='desc'> Extract the right part of a pair</div><div class='code'><pre>curry : forall {a : Type, b : Type, c : Type} . ((a, b) -> c) -> a -> b -> c</pre></div><div class='desc'> curry converts an uncurried function to a curried function</div><div class='code'><pre>uncurry : forall {a : Type, b : Type, c : Type} . (a -> b -> c) -> (a, b) -> c</pre></div><div class='desc'> uncurry converts a curried function to a function on pairs</div><div class='code'><pre>comp : forall {k : Coeffect, n : k, m : k, a : Type, b : Type, c : Type} . (b [n] -> c) -> (a [m] -> b) [n] -> a [n * m] -> c</pre></div><div class='desc'> Coeffectful composition</div><div class='code'><pre>boxmap : forall {a : Type, b : Type, s : Coeffect, r : s} . (a -> b) [r] -> a [r] -> b [r]</pre></div><div class='desc'></div><div class='code'><pre>unbox : forall {a : Type, k : Coeffect} . a [(1 : k)] -> a</pre></div><div class='desc'></div><div class='code'><pre>disject : forall {a : Type, k : Coeffect, n : k, m : k} . a [m * n] -> (a [n]) [m]</pre></div><div class='desc'></div><div class='code'><pre>extract : forall {a : Type, s : Coeffect, r : s} . {((1 : s)) ≤ r} =>
    a [r] -> a</pre></div><div class='desc'></div><div class='code'><pre>pullPair : forall {a : Type, b : Type, k : Coeffect, n : k, m : k} . (a [n], b [m]) -> (a, b) [n ∧ m]</pre></div><div class='desc'> Pull coeffects of pair elements up to the pair</div><div class='code'><pre>copy : forall {a : Type, s : Coeffect} . a [(1 + 1 : s)] -> (a, a)</pre></div><div class='desc'></div><div class='code'><pre>flatten : forall {a : Type, n : Nat, m : Nat} . (a [n]) [m] -> a [n * m]</pre></div><div class='desc'> Flatten two boxes (with Nat grading)</div><div class='code'><pre>unflatten : forall {a : Type, n : Nat, m : Nat} . a [n * m] -> (a [n]) [m]</pre></div><div class='desc'> Expand two boxes (with Nat grading)</div></section>
</div>
</body>
</html>