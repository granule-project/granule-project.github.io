<!doctype html>
<html>
<head>
  <link rel="stylesheet" type="text/css" href="style.css" />
  <link rel="stylesheet" type="text/css" href="../style.css" />
  <title>Granule documentation - Primitives</title>
</head>
<body>
<div id="navigator">
  <b>Modules</b><br /><br />
<a href='../index.html'><i>Top-level</i><br /></a><ul><li><a href='Primitives.html'>Primitives</a></li><br /><li><a href='Bool.html'>Bool</a></li><li><a href='Cake.html'>Cake</a></li><li><a href='Choice.html'>Choice</a></li><li><a href='Coffee.html'>Coffee</a></li><li><a href='Either.html'>Either</a></li><li><a href='Existential.html'>Existential</a></li><li><a href='File.html'>File</a></li><li><a href='Fin.html'>Fin</a></li><li><a href='Fix.html'>Fix</a></li><li><a href='Graph.html'>Graph</a></li><li><a href='List.html'>List</a></li><li><a href='Maybe.html'>Maybe</a></li><li><a href='Nat.html'>Nat</a></li><li><a href='Parallel.html'>Parallel</a></li><li><a href='Prelude.html'>Prelude</a></li><li><a href='Result.html'>Result</a></li><li><a href='Stack.html'>Stack</a></li><li><a href='Vec.html'>Vec</a></li><li><a href='unknown.html'>unknown</a></li></ul>
</div>
<div id="content">
  <div id="logo">
    <img src="../images/gr-blue.png" />
  </div>
  <b>Built-in primitives</b><br /><br />
<section><h2>Meta-data</h2><ul><li><b>Description</b>: Built-in primitive definitions</li></ul></section><section><h2>Contents</h2><section><div class='mininav'><ul><li><a href='#corelinearfunctionalcombinators'> Core linear functional combinators</a></li><li><a href='#arithmetic'> Arithmetic</a></li><li><a href='#gradedpossiblity'> Graded Possiblity</a></li><li><a href='#io'> I/O</a></li><li><a href='#exceptions'> Exceptions</a></li><li><a href='#conversions'> Conversions</a></li><li><a href='#concurrencyandsessiontypes'> Concurrency and Session Types</a></li><li><a href='#concurrencyprimitivesusingsideeffects'> Concurrency primitives using side effects</a></li><li><a href='#filehandles'> File Handles</a></li><li><a href='#char'> Char</a></li><li><a href='#stringmanipulation'> String manipulation</a></li><li><a href='#cost'> Cost</a></li><li><a href='#uniquenessmodality'> Uniqueness modality</a></li><li><a href='#mutableandimmutablearrayoperations'> Mutable and immutable array operations</a></li><li><a href='#benchmarking'> Benchmarking</a></li><li><a href='#sensitivity'> Sensitivity</a></li></ul></div></section><a name = corelinearfunctionalcombinators><h3><a href='#' class='toplink'>[top]</a> Core linear functional combinators</h3></a><div class='code'><pre>data () where
    () </pre></div><div class='desc'> Unit type</div><div class='code'><pre>use : forall {a : Type} . a -> a [1]</pre></div><div class='desc'> Allows a linear variable to be promoted to a graded modality specifying an exact usage of 1</div><div class='code'><pre>compose : forall {a : Type, b : Type, c : Type} . (b -> c) -> (a -> b) -> a -> c</pre></div><div class='desc'> Linear function composition</div><a name = arithmetic><h3><a href='#' class='toplink'>[top]</a> Arithmetic</h3></a><div class='code'><pre>div : Int -> Int -> Int</pre></div><div class='desc'> Integer division</div><a name = gradedpossiblity><h3><a href='#' class='toplink'>[top]</a> Graded Possiblity</h3></a><div class='code'><pre>pure : forall {a : Type} . a -> a <Pure></pre></div><div class='desc'> Inject into a computation for any graded monad</div><div class='code'><pre>fromPure : forall {a : Type} . a <Pure> -> a</pre></div><div class='desc'> Extract form a pure computation</div><a name = io><h3><a href='#' class='toplink'>[top]</a> I/O</h3></a><div class='code'><pre>data IOElem where
    Stdout ;
    Stdin ;
    Stderr ;
    Open ;
    Read ;
    Write ;
    IOExcept ;
    Close </pre></div><div class='desc'> IO effect operation information</div><div class='code'><pre>fromStdin : String <{Stdin}></pre></div><div class='desc'> Read from standard input</div><div class='code'><pre>toStdout : String -> () <{Stdout}></pre></div><div class='desc'> Write to standard output</div><div class='code'><pre>toStderr : String -> () <{Stderr}></pre></div><div class='desc'> Write to standard output</div><a name = exceptions><h3><a href='#' class='toplink'>[top]</a> Exceptions</h3></a><div class='code'><pre>throw : forall {a : Type, k : Coeffect} . (a [(0 : k)]) <MayFail></pre></div><br /><a name = conversions><h3><a href='#' class='toplink'>[top]</a> Conversions</h3></a><div class='code'><pre>showChar : Char -> String</pre></div><br /><div class='code'><pre>intToFloat : Int -> Float</pre></div><br /><div class='code'><pre>showInt : Int -> String</pre></div><br /><div class='code'><pre>showFloat : Float -> String</pre></div><br /><div class='code'><pre>readInt : String -> Int</pre></div><br /><a name = concurrencyandsessiontypes><h3><a href='#' class='toplink'>[top]</a> Concurrency and Session Types</h3></a><div class='code'><pre>fork : forall {s : Protocol, k : Coeffect, c : k} . {SingleAction s, ExactSemiring k} =>
    ((Chan s) [c] -> () <Session>) -> ((Chan (Dual s)) [c]) <Session></pre></div><br /><div class='code'><pre>forkLinear : forall {s : Protocol} . (LChan s -> ()) -> LChan (Dual s)</pre></div><br /><div class='code'><pre>forkLinear' : forall {p : Protocol, s : Coeffect} . ((LChan p) [(1 : s)] -> ()) -> LChan (Dual p)</pre></div><br /><div class='code'><pre>send : forall {a : Type, s : Protocol} . LChan (Send a s) -> a -> LChan s</pre></div><br /><div class='code'><pre>recv : forall {a : Type, s : Protocol} . LChan (Recv a s) -> (a, LChan s)</pre></div><br /><div class='code'><pre>close : LChan End -> ()</pre></div><br /><div class='code'><pre>selectLeft : forall {p1 : Protocol, p2 : Protocol} . LChan (Select p1 p2) -> LChan p1</pre></div><br /><div class='code'><pre>selectRight : forall {p1 : Protocol, p2 : Protocol} . LChan (Select p1 p2) -> LChan p2</pre></div><br /><div class='code'><pre>offer : forall {p1 : Protocol, p2 : Protocol, a : Type} . (LChan p1 -> a) -> (LChan p2 -> a) -> LChan (Offer p1 p2) -> a</pre></div><br /><div class='code'><pre>forkNonLinear : forall {p : Protocol, s : Coeffect, r : s} . {SingleAction p, ExactSemiring s} =>
    ((LChan p) [r] -> ()) -> (LChan (Dual p)) [r]</pre></div><br /><div class='code'><pre>forkMulticast : forall {p : Protocol, n : Nat} . {Sends p} =>
    (LChan (Graded n p) -> ()) -> N n -> Vec n (LChan (Dual p))</pre></div><br /><div class='code'><pre>forkReplicate : forall {p : Protocol, n : Nat} . {ReceivePrefix p} =>
    (LChan p -> ()) [0..n] -> N n -> Vec n ((LChan (Dual p)) [0..1])</pre></div><br /><div class='code'><pre>forkReplicateExactly : forall {p : Protocol, n : Nat} . {ReceivePrefix p} =>
    (LChan p -> ()) [n] -> N n -> Vec n (LChan (Dual p))</pre></div><br /><a name = concurrencyprimitivesusingsideeffects><h3><a href='#' class='toplink'>[top]</a> Concurrency primitives using side effects</h3></a><div class='code'><pre>gsend : forall {a : Type, s : Protocol} . Chan (Send a s) -> a -> (Chan s) <Session></pre></div><br /><div class='code'><pre>grecv : forall {a : Type, s : Protocol} . Chan (Recv a s) -> (a, Chan s) <Session></pre></div><br /><div class='code'><pre>gclose : Chan End -> () <Session></pre></div><br /><a name = filehandles><h3><a href='#' class='toplink'>[top]</a> File Handles</h3></a><div class='code'><pre>data Handle HandleType -> Type where
    </pre></div><br /><div class='code'><pre>data HandleType where
    R ;
    W ;
    A ;
    RW </pre></div><br /><div class='code'><pre>data IOMode HandleType -> Type where
    ReadMode : IOMode R;
    WriteMode : IOMode W;
    AppendMode : IOMode A;
    ReadWriteMode : IOMode RW</pre></div><br /><div class='code'><pre>openHandle : forall {m : HandleType} . IOMode m -> String -> (Handle m) <{Open, IOExcept}></pre></div><br /><div class='code'><pre>readChar : Handle R -> (Handle R, Char) <{Read, IOExcept}></pre></div><br /><div class='code'><pre>readChar' : Handle RW -> (Handle RW, Char) <{Read, IOExcept}></pre></div><br /><div class='code'><pre>appendChar : Handle A -> Char -> (Handle A) <{Write, IOExcept}></pre></div><br /><div class='code'><pre>writeChar : Handle W -> Char -> (Handle W) <{Write, IOExcept}></pre></div><br /><div class='code'><pre>writeChar' : Handle RW -> Char -> (Handle RW) <{Write, IOExcept}></pre></div><br /><div class='code'><pre>closeHandle : forall {m : HandleType} . Handle m -> () <{Close, IOExcept}></pre></div><br /><div class='code'><pre>isEOF : Handle R -> (Handle R, Bool) <{Read, IOExcept}></pre></div><br /><div class='code'><pre>isEOF' : Handle RW -> (Handle RW, Bool) <{Read, IOExcept}></pre></div><br /><a name = char><h3><a href='#' class='toplink'>[top]</a> Char</h3></a><div class='code'><pre>charToInt : Char -> Int</pre></div><br /><div class='code'><pre>charFromInt : Int -> Char</pre></div><br /><div class='code'><pre>moveChar : Char -> Char [(0 : Ext Nat)..∞]</pre></div><br /><div class='code'><pre>moveInt : Int -> Int [(0 : Ext Nat)..∞]</pre></div><br /><div class='code'><pre>moveString : String -> String [(0 : Ext Nat)..∞]</pre></div><br /><a name = stringmanipulation><h3><a href='#' class='toplink'>[top]</a> String manipulation</h3></a><div class='code'><pre>stringAppend : String -> String -> String</pre></div><br /><div class='code'><pre>stringUncons : String -> Maybe (Char, String)</pre></div><br /><div class='code'><pre>stringCons : Char -> String -> String</pre></div><br /><div class='code'><pre>stringUnsnoc : String -> Maybe (String, Char)</pre></div><br /><div class='code'><pre>stringSnoc : String -> Char -> String</pre></div><br /><a name = cost><h3><a href='#' class='toplink'>[top]</a> Cost</h3></a><div class='code'><pre>tick : () <1></pre></div><br /><a name = uniquenessmodality><h3><a href='#' class='toplink'>[top]</a> Uniqueness modality</h3></a><div class='code'><pre>uniqueReturn : forall {a : Type} . *a -> !a</pre></div><br /><div class='code'><pre>uniqueBind : forall {a : Type, b : Type} . (*a -> !b) -> !a -> !b</pre></div><br /><div class='code'><pre>uniquePush : forall {a : Type, b : Type} . *(a, b) -> (*a, *b)</pre></div><br /><div class='code'><pre>uniquePull : forall {a : Type, b : Type} . (*a, *b) -> *(a, b)</pre></div><br /><div class='code'><pre>reveal : forall {a : Type} . a *Trusted -> a [Lo]</pre></div><br /><div class='code'><pre>trustedBind : forall {a : Type, b : Type} . (a *Trusted -> b [Lo]) -> a [Lo] -> b [Lo]</pre></div><br /><a name = mutableandimmutablearrayoperations><h3><a href='#' class='toplink'>[top]</a> Mutable and immutable array operations</h3></a><div class='code'><pre>newFloatArray : Int -> *FloatArray</pre></div><br /><div class='code'><pre>newFloatArrayI : Int -> FloatArray</pre></div><br /><div class='code'><pre>readFloatArray : *FloatArray -> Int -> (Float, *FloatArray)</pre></div><br /><div class='code'><pre>readFloatArrayI : FloatArray -> Int -> (Float, FloatArray)</pre></div><br /><div class='code'><pre>writeFloatArray : *FloatArray -> Int -> Float -> *FloatArray</pre></div><br /><div class='code'><pre>writeFloatArrayI : FloatArray -> Int -> Float -> FloatArray</pre></div><br /><div class='code'><pre>lengthFloatArray : *FloatArray -> (Int, *FloatArray)</pre></div><br /><div class='code'><pre>lengthFloatArrayI : FloatArray -> (Int, FloatArray)</pre></div><br /><div class='code'><pre>deleteFloatArray : *FloatArray -> ()</pre></div><br /><a name = benchmarking><h3><a href='#' class='toplink'>[top]</a> Benchmarking</h3></a><div class='code'><pre>data BenchList where
    BenchGroup String BenchList BenchList;
    Bench Int String Int [(0 : Ext Nat)..∞] -> () <{Stdout}> BenchList;
    Done </pre></div><br /><div class='code'><pre>mkIOBenchMain : BenchList -> () <Pure></pre></div><br /><a name = sensitivity><h3><a href='#' class='toplink'>[top]</a> Sensitivity</h3></a><div class='code'><pre>scale : (k : Float) -> DFloat [k] -> DFloat</pre></div><br /><div class='code'><pre>data Capability where
    Console ;
    TimeDate </pre></div><br /><div class='code'><pre>cap : (c : Capability) -> () [{c}] -> CapabilityType c</pre></div><br /></section>
</div>
</body>
</html>