<!doctype html>
<html>
<head>
  <link rel="stylesheet" type="text/css" href="style.css" />
  <link rel="stylesheet" type="text/css" href="../style.css" />
  <title>Granule documentation - Primitives</title>
</head>
<body>
<div id="navigator">
  <b>Modules</b><br /><br />
<a href='../index.html'><i>Top-level</i><br /></a><ul><li><a href='Primitives.html'>Primitives</a></li><br /><li><a href='Bool.html'>Bool</a></li><li><a href='Cake.html'>Cake</a></li><li><a href='Choice.html'>Choice</a></li><li><a href='Either.html'>Either</a></li><li><a href='Existential.html'>Existential</a></li><li><a href='File.html'>File</a></li><li><a href='Fin.html'>Fin</a></li><li><a href='Fix.html'>Fix</a></li><li><a href='Graph.html'>Graph</a></li><li><a href='List.html'>List</a></li><li><a href='Maybe.html'>Maybe</a></li><li><a href='Nat.html'>Nat</a></li><li><a href='Parallel.html'>Parallel</a></li><li><a href='Prelude.html'>Prelude</a></li><li><a href='Result.html'>Result</a></li><li><a href='Stack.html'>Stack</a></li><li><a href='Vec.html'>Vec</a></li></ul>
</div>
<div id="content">
  <div id="logo">
    <img src="../images/gr-blue.png" />
  </div>
  <b>Built-in primitives</b><br /><br />
<section><h2>Meta-data</h2><ul></ul></section><section><h2>Data types</h2><div class='code'><pre>data () where
    () </pre></div><div class='code'><pre>data IOElem where
    Stdout ;
    Stdin ;
    Stderr ;
    Open ;
    Read ;
    Write ;
    IOExcept ;
    Close </pre></div><div class='code'><pre>data Handle HandleType -> Type where
    </pre></div><div class='code'><pre>data HandleType where
    R ;
    W ;
    A ;
    RW </pre></div><div class='code'><pre>data IOMode HandleType -> Type where
    ReadMode : IOMode R;
    WriteMode : IOMode W;
    AppendMode : IOMode A;
    ReadWriteMode : IOMode RW</pre></div><div class='code'><pre>data ArrayStack (capacity : Nat) (maxIndex : Nat) (a : Type) where
    </pre></div><div class='code'><pre>data BenchList where
    BenchGroup String BenchList BenchList;
    Bench Int String Int [(0 : Ext Nat)..∞] -> () <{Stdout}> BenchList;
    Done </pre></div><div class='code'><pre>data Capability where
    Console ;
    TimeDate </pre></div></section><section><h2>Definitions</h2><div class='code'><pre>use : forall {a : Type} . a -> a [1]</pre></div><div class='desc'> Allows a linear variable to be promoted to a graded modality specifying an exact usage of 1</div><div class='code'><pre>compose : forall {a : Type, b : Type, c : Type} . (b -> c) -> (a -> b) -> a -> c</pre></div><div class='desc'> Linear function composition</div><div class='code'><pre>div : Int -> Int -> Int</pre></div><div class='desc'> Integer division</div><div class='code'><pre>pure : forall {a : Type} . a -> a <Pure></pre></div><div class='desc'> Inject into a computation for any graded monad</div><div class='code'><pre>fromPure : forall {a : Type} . a <Pure> -> a</pre></div><div class='desc'> Extract form a pure computation</div><div class='code'><pre>fromStdin : String <{Stdin}></pre></div><div class='desc'> Read from standard input</div><div class='code'><pre>toStdout : String -> () <{Stdout}></pre></div><div class='desc'> Write to standard output</div><div class='code'><pre>toStderr : String -> () <{Stderr}></pre></div><div class='desc'> Write to standard output</div><div class='code'><pre>throw : forall {a : Type, k : Coeffect} . (a [(0 : k)]) <MayFail></pre></div><div class='desc'></div><div class='code'><pre>showChar : Char -> String</pre></div><div class='desc'></div><div class='code'><pre>intToFloat : Int -> Float</pre></div><div class='desc'></div><div class='code'><pre>showInt : Int -> String</pre></div><div class='desc'></div><div class='code'><pre>showFloat : Float -> String</pre></div><div class='desc'></div><div class='code'><pre>readInt : String -> Int</pre></div><div class='desc'></div><div class='code'><pre>fork : forall {s : Protocol, k : Coeffect, c : k} . {SingleAction s, ExactSemiring k} =>
    ((Chan s) [c] -> () <Session>) -> ((Chan (Dual s)) [c]) <Session></pre></div><div class='desc'></div><div class='code'><pre>forkLinear : forall {s : Protocol} . (LChan s -> ()) -> LChan (Dual s)</pre></div><div class='desc'></div><div class='code'><pre>forkLinear' : forall {p : Protocol, s : Coeffect} . ((LChan p) [(1 : s)] -> ()) -> LChan (Dual p)</pre></div><div class='desc'></div><div class='code'><pre>send : forall {a : Type, s : Protocol} . LChan (Send a s) -> a -> LChan s</pre></div><div class='desc'></div><div class='code'><pre>recv : forall {a : Type, s : Protocol} . LChan (Recv a s) -> (a, LChan s)</pre></div><div class='desc'></div><div class='code'><pre>close : LChan End -> ()</pre></div><div class='desc'></div><div class='code'><pre>selectLeft : forall {p1 : Protocol, p2 : Protocol} . LChan (Select p1 p2) -> LChan p1</pre></div><div class='desc'></div><div class='code'><pre>selectRight : forall {p1 : Protocol, p2 : Protocol} . LChan (Select p1 p2) -> LChan p2</pre></div><div class='desc'></div><div class='code'><pre>offer : forall {p1 : Protocol, p2 : Protocol, a : Type} . (LChan p1 -> a) -> (LChan p2 -> a) -> LChan (Offer p1 p2) -> a</pre></div><div class='desc'></div><div class='code'><pre>gsend : forall {a : Type, s : Protocol} . Chan (Send a s) -> a -> (Chan s) <Session></pre></div><div class='desc'></div><div class='code'><pre>grecv : forall {a : Type, s : Protocol} . Chan (Recv a s) -> (a, Chan s) <Session></pre></div><div class='desc'></div><div class='code'><pre>gclose : Chan End -> () <Session></pre></div><div class='desc'></div><div class='code'><pre>forkNonLinear : forall {p : Protocol, s : Coeffect, r : s} . {SingleAction p, ExactSemiring s} =>
    ((LChan p) [r] -> ()) -> (LChan (Dual p)) [r]</pre></div><div class='desc'></div><div class='code'><pre>forkMulticast : forall {p : Protocol, n : Nat} . {Sends p} =>
    (LChan (Graded n p) -> ()) -> N n -> Vec n (LChan (Dual p))</pre></div><div class='desc'></div><div class='code'><pre>forkReplicate : forall {p : Protocol, n : Nat} . {ReceivePrefix p} =>
    (LChan p -> ()) [0..n] -> N n -> Vec n ((LChan (Dual p)) [0..1])</pre></div><div class='desc'></div><div class='code'><pre>forkReplicateExactly : forall {p : Protocol, n : Nat} . {ReceivePrefix p} =>
    (LChan p -> ()) [n] -> N n -> Vec n (LChan (Dual p))</pre></div><div class='desc'></div><div class='code'><pre>openHandle : forall {m : HandleType} . IOMode m -> String -> (Handle m) <{Open, IOExcept}></pre></div><div class='desc'></div><div class='code'><pre>readChar : Handle R -> (Handle R, Char) <{Read, IOExcept}></pre></div><div class='desc'></div><div class='code'><pre>readChar' : Handle RW -> (Handle RW, Char) <{Read, IOExcept}></pre></div><div class='desc'></div><div class='code'><pre>appendChar : Handle A -> Char -> (Handle A) <{Write, IOExcept}></pre></div><div class='desc'></div><div class='code'><pre>writeChar : Handle W -> Char -> (Handle W) <{Write, IOExcept}></pre></div><div class='desc'></div><div class='code'><pre>writeChar' : Handle RW -> Char -> (Handle RW) <{Write, IOExcept}></pre></div><div class='desc'></div><div class='code'><pre>closeHandle : forall {m : HandleType} . Handle m -> () <{Close, IOExcept}></pre></div><div class='desc'></div><div class='code'><pre>isEOF : Handle R -> (Handle R, Bool) <{Read, IOExcept}></pre></div><div class='desc'></div><div class='code'><pre>isEOF' : Handle RW -> (Handle RW, Bool) <{Read, IOExcept}></pre></div><div class='desc'></div><div class='code'><pre>charToInt : Char -> Int</pre></div><div class='desc'></div><div class='code'><pre>charFromInt : Int -> Char</pre></div><div class='desc'></div><div class='code'><pre>moveChar : Char -> Char [(0 : Ext Nat)..∞]</pre></div><div class='desc'></div><div class='code'><pre>moveInt : Int -> Int [(0 : Ext Nat)..∞]</pre></div><div class='desc'></div><div class='code'><pre>moveString : String -> String [(0 : Ext Nat)..∞]</pre></div><div class='desc'></div><div class='code'><pre>stringAppend : String -> String -> String</pre></div><div class='desc'></div><div class='code'><pre>stringUncons : String -> Maybe (Char, String)</pre></div><div class='desc'></div><div class='code'><pre>stringCons : Char -> String -> String</pre></div><div class='desc'></div><div class='code'><pre>stringUnsnoc : String -> Maybe (String, Char)</pre></div><div class='desc'></div><div class='code'><pre>stringSnoc : String -> Char -> String</pre></div><div class='desc'></div><div class='code'><pre>push : forall {a : Type, cap : Nat, maxIndex : Nat} . {maxIndex < cap} =>
    ArrayStack cap maxIndex a -> a -> ArrayStack cap (maxIndex + 1) a</pre></div><div class='desc'></div><div class='code'><pre>pop : forall {a : Type, cap : Nat, maxIndex : Nat} . {maxIndex > 0} =>
    ArrayStack cap maxIndex a -> (a, ArrayStack cap (maxIndex - 1) a)</pre></div><div class='desc'></div><div class='code'><pre>allocate : forall {a : Type, cap : Nat} . N cap -> ArrayStack cap 0 a</pre></div><div class='desc'></div><div class='code'><pre>swap : forall {a : Type, cap : Nat, maxIndex : Nat} . ArrayStack cap (maxIndex + 1) a -> Fin (maxIndex + 1) -> a -> (a, ArrayStack cap (maxIndex + 1) a)</pre></div><div class='desc'></div><div class='code'><pre>copyArray : forall {a : Type, cap : Nat, maxIndex : Nat} . ArrayStack cap maxIndex (a [2]) -> (ArrayStack cap maxIndex a, ArrayStack cap maxIndex a)</pre></div><div class='desc'></div><div class='code'><pre>tick : () <1></pre></div><div class='desc'></div><div class='code'><pre>uniqueReturn : forall {a : Type} . *a -> !a</pre></div><div class='desc'></div><div class='code'><pre>uniqueBind : forall {a : Type, b : Type} . (*a -> !b) -> !a -> !b</pre></div><div class='desc'></div><div class='code'><pre>uniquePush : forall {a : Type, b : Type} . *(a, b) -> (*a, *b)</pre></div><div class='desc'></div><div class='code'><pre>uniquePull : forall {a : Type, b : Type} . (*a, *b) -> *(a, b)</pre></div><div class='desc'></div><div class='code'><pre>reveal : forall {a : Type} . a *Trusted -> a [Lo]</pre></div><div class='desc'></div><div class='code'><pre>trustedBind : forall {a : Type, b : Type} . (a *Trusted -> b [Lo]) -> a [Lo] -> b [Lo]</pre></div><div class='desc'></div><div class='code'><pre>newFloatArray : Int -> *FloatArray</pre></div><div class='desc'></div><div class='code'><pre>newFloatArrayI : Int -> FloatArray</pre></div><div class='desc'></div><div class='code'><pre>readFloatArray : *FloatArray -> Int -> (Float, *FloatArray)</pre></div><div class='desc'></div><div class='code'><pre>readFloatArrayI : FloatArray -> Int -> (Float, FloatArray)</pre></div><div class='desc'></div><div class='code'><pre>writeFloatArray : *FloatArray -> Int -> Float -> *FloatArray</pre></div><div class='desc'></div><div class='code'><pre>writeFloatArrayI : FloatArray -> Int -> Float -> FloatArray</pre></div><div class='desc'></div><div class='code'><pre>lengthFloatArray : *FloatArray -> (Int, *FloatArray)</pre></div><div class='desc'></div><div class='code'><pre>lengthFloatArrayI : FloatArray -> (Int, FloatArray)</pre></div><div class='desc'></div><div class='code'><pre>deleteFloatArray : *FloatArray -> ()</pre></div><div class='desc'></div><div class='code'><pre>mkIOBenchMain : BenchList -> () <Pure></pre></div><div class='desc'></div><div class='code'><pre>scale : (k : Float) -> DFloat [k] -> DFloat</pre></div><div class='desc'></div><div class='code'><pre>cap : (c : Capability) -> () [{c}] -> CapabilityType c</pre></div><div class='desc'></div><div class='code'><pre>with : forall {a : Type, b : Type} . a [0..1] -> b [0..1] -> a & b</pre></div><div class='desc'></div><div class='code'><pre>projL : forall {a : Type, b : Type} . a & b -> a</pre></div><div class='desc'></div><div class='code'><pre>projR : forall {a : Type, b : Type} . a & b -> b</pre></div><div class='desc'></div></section>
</div>
</body>
</html>