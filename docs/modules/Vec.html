<!doctype html>
<html>
<head>
  <link rel="stylesheet" type="text/css" href="style.css" />
  <link rel="stylesheet" type="text/css" href="../style.css" />
  <title>Granule documentation - Vec</title>
</head>
<body>
<div id="navigator">
  <b>Modules</b><br /><br />
<a href='../index.html'><i>Top-level</i><br /></a><ul><li><a href='Primitives.html'>Primitives</a></li><br /><li><a href='Bool.html'>Bool</a></li><li><a href='Cake.html'>Cake</a></li><li><a href='Choice.html'>Choice</a></li><li><a href='Coffee.html'>Coffee</a></li><li><a href='Either.html'>Either</a></li><li><a href='Existential.html'>Existential</a></li><li><a href='File.html'>File</a></li><li><a href='Fin.html'>Fin</a></li><li><a href='Fix.html'>Fix</a></li><li><a href='Graph.html'>Graph</a></li><li><a href='List.html'>List</a></li><li><a href='Maybe.html'>Maybe</a></li><li><a href='Nat.html'>Nat</a></li><li><a href='Parallel.html'>Parallel</a></li><li><a href='Prelude.html'>Prelude</a></li><li><a href='Result.html'>Result</a></li><li><a href='Stack.html'>Stack</a></li><li><a href='Vec.html'>Vec</a></li></ul>
</div>
<div id="content">
  <div id="logo">
    <img src="../images/gr-blue.png" />
  </div>
  <b>Module Vec</b><br /><br />
<section><h2>Meta-data</h2><ul><li><b>Description</b>: Base library for operations on type-indexed vectors</li><li><b>Authors</b>: Dominic Orchard, Vilem-Benjamin Liepelt</li><li><b>License</b>: BSD3</li><li><b>Copyright</b>: (c) Authors 2018</li><li><b>Issue-tracking</b>: https://github.com/dorchard/granule/issues</li><li><b>Repository</b>: https://github.com/dorchard/granule</li></ul></section><section><h2>Contents</h2><div class='code'><pre><span class='keyword'>data</span> <span class='constName'>Vec</span> (n : <span class='constName'>Nat</span>) (t : <span class='constName'>Type</span>) <span class='keyword'>where</span>
    Nil  : <span class='constName'>Vec</span> 0 t
  ; Cons : t -> <span class='constName'>Vec</span> n t -> <span class='constName'>Vec</span> (n + 1) t</pre></div><div class='desc'> Sized vectors</div><div class='code'><pre>length : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, n : <span class='constName'>Nat</span>} 
       . <span class='constName'>Vec</span> n (a [<span class='coeff'>0</span>]) -> <span class='constName'>N</span> n</pre></div><div class='desc'> Length of an indexed vector into an indexed nat discarding the elements</div><div class='code'><pre>length' : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, n : <span class='constName'>Nat</span>} 
        . <span class='constName'>Vec</span> n a -> (<span class='constName'>N</span> n, <span class='constName'>Vec</span> n a)</pre></div><br /><div class='code'><pre>map : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, b : <span class='constName'>Type</span>, n : <span class='constName'>Nat</span>} 
    . (a -> b) [<span class='coeff'>n</span>] -> <span class='constName'>Vec</span> n a -> <span class='constName'>Vec</span> n b</pre></div><br /><div class='code'><pre>index : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, n : <span class='constName'>Nat</span>, m : <span class='constName'>Nat</span>} 
      . {m > n} =>
    <span class='constName'>N</span> n -> (<span class='constName'>Vec</span> m a) [<span class='coeff'>0..1</span>] -> a</pre></div><div class='desc'> Safe random-access indexing from a vector</div><div class='code'><pre>foldr : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, b : <span class='constName'>Type</span>, n : <span class='constName'>Nat</span>} 
      . (a -> b -> b) [<span class='coeff'>n</span>] -> b -> <span class='constName'>Vec</span> n a -> b</pre></div><div class='desc'> Right fold</div><div class='code'><pre>foldr1 : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, n : <span class='constName'>Nat</span>} 
       . (a -> a -> a) [<span class='coeff'>n</span>] -> <span class='constName'>Vec</span> (n + 1) a -> a</pre></div><div class='desc'> Foldr1 (no need for an initial value as vector has at least one element)</div><div class='code'><pre>foldl : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, b : <span class='constName'>Type</span>, n : <span class='constName'>Nat</span>} 
      . (b -> a -> b) [<span class='coeff'>n</span>] -> b -> <span class='constName'>Vec</span> n a -> b</pre></div><div class='desc'> Left fold</div><div class='code'><pre>append : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, m : <span class='constName'>Nat</span>, n : <span class='constName'>Nat</span>} 
       . <span class='constName'>Vec</span> n a -> <span class='constName'>Vec</span> m a -> <span class='constName'>Vec</span> (n + m) a</pre></div><div class='desc'> Append two vectors</div><div class='code'><pre>drop : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, m : <span class='constName'>Nat</span>, n : <span class='constName'>Nat</span>} 
     . <span class='constName'>N</span> m -> (<span class='constName'>Vec</span> n a) [<span class='coeff'>0..1</span>] -> <span class='constName'>Vec</span> (n - m) a</pre></div><div class='desc'> Drop the first <span class='inline'>m</span> elements</div><div class='code'><pre>take : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, m : <span class='constName'>Nat</span>, n : <span class='constName'>Nat</span>} 
     . <span class='constName'>N</span> m -> (<span class='constName'>Vec</span> n a) [<span class='coeff'>0..1</span>] -> <span class='constName'>Vec</span> (n + (m - n)) a</pre></div><div class='desc'> Take the first <span class='inline'>m</span> elements</div><div class='code'><pre>head : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, n : <span class='constName'>Nat</span>} 
     . (<span class='constName'>Vec</span> (n + 1) a) [<span class='coeff'>0..1</span>] -> a</pre></div><div class='desc'> Return the first item (head) of the vector NB: non-linear in the vector</div><div class='code'><pre>tail : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, n : <span class='constName'>Nat</span>} 
     . (<span class='constName'>Vec</span> (n + 1) a) [<span class='coeff'>0..1</span>] -> <span class='constName'>Vec</span> n a</pre></div><div class='desc'> Return the vector with the first item removed NB: non-linear in the vector</div><div class='code'><pre>uncons : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, n : <span class='constName'>Nat</span>} 
       . <span class='constName'>Vec</span> (n + 1) a -> (a, <span class='constName'>Vec</span> n a)</pre></div><div class='desc'> Take a vector and return the head element paired with the tail</div><div class='code'><pre>split : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, m : <span class='constName'>Nat</span>, n : <span class='constName'>Nat</span>} 
      . <span class='constName'>N</span> n -> <span class='constName'>Vec</span> (n + m) a -> (<span class='constName'>Vec</span> n a, <span class='constName'>Vec</span> m a)</pre></div><div class='desc'> Split a vector at position 'n'</div><div class='code'><pre>sum : <span class='keyword'>forall</span> {n : <span class='constName'>Nat</span>} 
    . <span class='constName'>Vec</span> n <span class='constName'>Int</span> -> <span class='constName'>Int</span></pre></div><div class='desc'> Sum a vector of integers (using <span class='inline'>foldr</span>)</div><div class='code'><pre>product : <span class='keyword'>forall</span> {n : <span class='constName'>Nat</span>} 
        . <span class='constName'>Vec</span> n <span class='constName'>Int</span> -> <span class='constName'>Int</span></pre></div><div class='desc'> Product of a vector of integers (using <span class='inline'>foldr</span>)</div><div class='code'><pre>replicate : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, n : <span class='constName'>Nat</span>} 
          . <span class='constName'>N</span> n -> a [<span class='coeff'>n</span>] -> <span class='constName'>Vec</span> n a</pre></div><div class='desc'> Replicate n x is a vector of length n with x the value of every element</div><div class='code'><pre>range : <span class='keyword'>forall</span> {n : <span class='constName'>Nat</span>} 
      . <span class='constName'>N</span> n -> <span class='constName'>Vec</span> n <span class='constName'>Int</span></pre></div><div class='desc'> Make a vector of length n with all integers from 0 to n-1  e.g. <span class='inline'>range (S (S (S (S Z))))</span> should yield  <span class='inline'>Cons 0 (Cons 1 (Cons 2 (Cons 3 Nil)))</span></div><div class='code'><pre>range' : <span class='keyword'>forall</span> {n : <span class='constName'>Nat</span>} 
       . <span class='constName'>N</span> n -> <span class='constName'>Int</span> [<span class='coeff'>n</span>] -> <span class='constName'>Vec</span> n <span class='constName'>Int</span></pre></div><div class='desc'> Make a vector of length n with all integers from <span class='inline'>start</span> up until <span class='inline'>n + i - 1</span>  e.g. <span class='inline'>range' (S (S (S (S Z)))) [-6]</span> should yield <span class='inline'>Cons -6 (Cons -5 (Cons -4 (Cons -3 Nil)))</span></div><div class='code'><pre>pullVec : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, s : <span class='constName'>Coeffect</span>, k : s, n : <span class='constName'>Nat</span>} 
        . <span class='constName'>Vec</span> n (a [<span class='coeff'>k</span>]) -> (<span class='constName'>Vec</span> n a) [<span class='coeff'>k</span>]</pre></div><div class='desc'> pullVec pulls non linearity in elements into a non linearity on the whole vector</div><div class='code'><pre>pushVec : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, s : <span class='constName'>Coeffect</span>, k : s, n : <span class='constName'>Nat</span>} 
        . {((1 : s)) ≤ k} =>
    (<span class='constName'>Vec</span> n a) [<span class='coeff'>k</span>] -> <span class='constName'>Vec</span> n (a [<span class='coeff'>k</span>])</pre></div><div class='desc'> pushVec pushes in non linearity of vector into the elements</div><div class='code'><pre>copySpine : <span class='keyword'>forall</span> {a : <span class='constName'>Type</span>, n : <span class='constName'>Nat</span>} 
          . <span class='constName'>Vec</span> n a -> (<span class='constName'>Vec</span> n <span class='constName'>()</span>, <span class='constName'>Vec</span> n a)</pre></div><div class='desc'> Copy the spine of a vector</div><div class='code'><pre>stringToVec : <span class='constName'>String</span> -> <span class='keyword'>exists</span> {n:<span class='constName'>Nat</span>} 
            . <span class='constName'>Vec</span> n <span class='constName'>Char</span></pre></div><div class='desc'> Convert a string into a vector</div></section>
</div>
</body>
</html>