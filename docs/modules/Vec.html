<!doctype html>
<html>
<head>
  <link rel="stylesheet" type="text/css" href="style.css" />
  <link rel="stylesheet" type="text/css" href="../style.css" />
  <title>Granule documentation - Vec</title>
</head>
<body>
<div id="navigator">
  <b>Modules</b><br /><br />
<a href='../index.html'><i>Top-level</i><br /></a><ul><li><a href='Primitives.html'>Primitives</a></li><br /><li><a href='Bool.html'>Bool</a></li><li><a href='Choice.html'>Choice</a></li><li><a href='Either.html'>Either</a></li><li><a href='Existential.html'>Existential</a></li><li><a href='File.html'>File</a></li><li><a href='Fin.html'>Fin</a></li><li><a href='Fix.html'>Fix</a></li><li><a href='Graph.html'>Graph</a></li><li><a href='List.html'>List</a></li><li><a href='Maybe.html'>Maybe</a></li><li><a href='Nat.html'>Nat</a></li><li><a href='Parallel.html'>Parallel</a></li><li><a href='Prelude.html'>Prelude</a></li><li><a href='Result.html'>Result</a></li><li><a href='Stack.html'>Stack</a></li><li><a href='Vec.html'>Vec</a></li></ul>
</div>
<div id="content">
  <div id="logo">
    <img src="../images/gr-blue.png" />
  </div>
  <b>Module Vec</b><br /><br />
<section><h2>Meta-data</h2><ul><li><b>Module</b>: Vec</li><li><b>Description</b>: Base library for operations on type-indexed vectors</li><li><b>Authors</b>: Dominic Orchard, Vilem-Benjamin Liepelt</li><li><b>License</b>: BSD3</li><li><b>Copyright</b>: (c) Authors 2018</li><li><b>Issue-tracking</b>: https://github.com/dorchard/granule/issues</li><li><b>Repository</b>: https://github.com/dorchard/granule</li></ul></section><section><h2>Data types</h2><div class='code'>data Vec (n, Nat) (t, Type) where
  Nil : Vec 0 t;
  Cons : t -> Vec n t -> Vec (n + 1) t</div></section><section><h2>Definitions</h2><div class='code'>length : forall {a : Type, n : Nat} . Vec n (a [0]) -> N n</div><div class='desc'></div><div class='code'>length' : forall {a : Type, n : Nat} . Vec n a -> (N n, Vec n a)</div><div class='desc'></div><div class='code'>map : forall {a : Type, b : Type, n : Nat} . (a -> b) [n] -> Vec n a -> Vec n b</div><div class='desc'> Map function</div><div class='code'>index : forall {a : Type, n : Nat, m : Nat} . {m > n} =>
    N n -> (Vec m a) [0..1] -> a</div><div class='desc'></div><div class='code'>foldr : forall {a : Type, b : Type, n : Nat} . (a -> b -> b) [n] -> b -> Vec n a -> b</div><div class='desc'></div><div class='code'>foldr1 : forall {a : Type, n : Nat} . (a -> a -> a) [n] -> Vec (n + 1) a -> a</div><div class='desc'></div><div class='code'>foldl : forall {a : Type, b : Type, n : Nat} . (b -> a -> b) [n] -> b -> Vec n a -> b</div><div class='desc'></div><div class='code'>append : forall {a : Type, m : Nat, n : Nat} . Vec n a -> Vec m a -> Vec (n + m) a</div><div class='desc'></div><div class='code'>drop : forall {a : Type, m : Nat, n : Nat} . N m -> (Vec n a) [0..1] -> Vec (n - m) a</div><div class='desc'></div><div class='code'>take : forall {a : Type, m : Nat, n : Nat} . N m -> (Vec n a) [0..1] -> Vec (n + (m - n)) a</div><div class='desc'></div><div class='code'>head : forall {a : Type, n : Nat} . (Vec (n + 1) a) [0..1] -> a</div><div class='desc'> Return the first item (head) of the vector NB: non-linear in the vector</div><div class='code'>tail : forall {a : Type, n : Nat} . (Vec (n + 1) a) [0..1] -> Vec n a</div><div class='desc'> Return the vector with the first item removed NB: non-linear in the vector</div><div class='code'>uncons : forall {a : Type, n : Nat} . Vec (n + 1) a -> (a, Vec n a)</div><div class='desc'></div><div class='code'>split : forall {a : Type, m : Nat, n : Nat} . N n -> Vec (n + m) a -> (Vec n a, Vec m a)</div><div class='desc'> Split a vector at position 'n'</div><div class='code'>sum : forall {n : Nat} . Vec n Int -> Int</div><div class='desc'> Simple folds</div><div class='code'>product : forall {n : Nat} . Vec n Int -> Int</div><div class='desc'></div><div class='code'>replicate : forall {a : Type, n : Nat} . N n -> a [n] -> Vec n a</div><div class='desc'> Replicate n x is a vector of length n with x the value of every element</div><div class='code'>range : forall {n : Nat} . N n -> Vec n Int</div><div class='desc'> Make a vector of length n with all integers from 0 to n-1     > range (S (S (S (S Z))))     Cons 0 (Cons 1 (Cons 2 (Cons 3 Nil)))</div><div class='code'>range' : forall {n : Nat} . N n -> Int [n] -> Vec n Int</div><div class='desc'> Make a vector of length n with all integers from `start` up until `n + i - 1`     > range' (S (S (S (S Z)))) [-6]     Cons -6 (Cons -5 (Cons -4 (Cons -3 Nil)))</div><div class='code'>pullVec : forall {a : Type, s : Coeffect, k : s, n : Nat} . Vec n (a [k]) -> (Vec n a) [k]</div><div class='desc'> pullVec pulls non linearity in elements into a non linearity on the whole vector</div><div class='code'>pushVec : forall {a : Type, s : Coeffect, k : s, n : Nat} . {((1 : s)) â‰¤ k} =>
    (Vec n a) [k] -> Vec n (a [k])</div><div class='desc'> pushVec pushes in non linearity of vector into the elements</div><div class='code'>copySpine : forall {a : Type, n : Nat} . Vec n a -> (Vec n (), Vec n a)</div><div class='desc'></div><div class='code'>stringToVec : String -> exists {n:Nat} . Vec n Char</div><div class='desc'></div></section>
</div>
</body>
</html>